# training-data
# Висновки щодо швидкості обробки даних: масив vs HashSet

## 1. Пошук елемента
- **Масив:**
  - Час пошуку елемента: `2185 наносекунд`.
  - Пошук виконується за допомогою лінійного обходу (O(n)).

- **HashSet:**
  - Час пошуку елемента: `25129 наносекунд`.
  - Теоретична складність O(1), але в реальності є накладні витрати на хешування.

**Висновок:**  
Для невеликих масивів пошук у масиві швидший через менші накладні витрати. Для великих обсягів даних `HashSet` забезпечує кращу продуктивність.

---

## 2. Пошук мінімального і максимального значення
- **Масив:**
  - Час пошуку: `5779 наносекунд`.

- **HashSet:**
  - Час пошуку: `19936769 наносекунд`.
  - Для цієї операції `HashSet` потребує перетворення в масив, що значно сповільнює роботу.

**Висновок:**  
Масив набагато швидший для таких операцій через прямий доступ до елементів.

---

## 3. Сортування
- Час сортування масиву: `244302 наносекунд`.
- У `HashSet` сортування неможливе напряму — потрібне перетворення у список, що додає витрати.

**Висновок:**  
Масив більш ефективний для операцій сортування.

---

## 4. Кількість елементів
- Кількість елементів у масиві: `200`.
- Кількість елементів у HashSet: `114` (унікальні елементи).

**Висновок:**  
`HashSet` автоматично усуває дублікати, що зручно для роботи з унікальними даними.

---

## 5. Операції зчитування і запису
- Результати сортування були записані у файл: `list/int.data.sorted`.

---

# Загальні висновки
- **Масив** підходить для:
  - Операцій із послідовним доступом (пошук мінімуму/максимуму, сортування).
  - Роботи з невеликими обсягами даних або коли важливий порядок елементів.

- **HashSet** підходить для:
  - Уникнення дублювання даних.
  - Швидкого пошуку у великих наборах даних.

---

# Рекомендація
- Використовувати **масив** для послідовного доступу до елементів.
- Використовувати **HashSet**, якщо потрібна унікальність даних або швидкий пошук у великих обсягах.
